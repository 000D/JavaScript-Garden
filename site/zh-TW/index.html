<!DOCTYPE html><html lang="zh-TW"><head><title>JavaScript 庭院</title><meta charset="utf-8"><meta name="description" content="JavaScript 語言中古怪用法及缺點的文件總集"><link rel="stylesheet" href="../style/garden.css" media="all"><link rel="stylesheet" href="../style/print.css" media="print"><!--[if lt IE 9]>
<script src="javascript/html5.js"></script>
<![endif]-->
</head><body><!-- Navigation--><nav id="nav_main"><div><ul><li><a href="/JavaScript-Garden/" title="JavaScript Garden in English">en</a></li><li><a href="/JavaScript-Garden/es" title="JavaScript Garden es Español">es</a></li><li><a href="/JavaScript-Garden/fi" title="JavaScript-puutarha suomeksi">fi</a></li><li><a href="/JavaScript-Garden/ja" title="JavaScript Garden in Japanese">ja</a></li><li><a href="/JavaScript-Garden/ko" title="JavaScript Garden">ko</a></li><li><a href="/JavaScript-Garden/pl" title="JavaScript Garden - ogród JavaScript po polsku">pl</a></li><li><a href="/JavaScript-Garden/ru" title="JavaScript Гарден по-русски">ru</a></li><li><a href="/JavaScript-Garden/tr" title="JavaScript Garden Türkçe">tr</a></li><li><a href="/JavaScript-Garden/zh" title="JavaScript Garden 中文翻译">zh</a></li></ul><a id="top" href="#intro" title="Back to top">#top</a><a id="hide_menu" class="tablet">Hide Menu</a></div><ul><li class="nav_intro"><h1><a href="#intro">簡介</a></h1><ul></ul></li><li class="nav_object"><h1><a href="#object">物件</a></h1><ul><li><a href="#object.general">Object Usage and Properties</a></li><li><a href="#object.prototype">The Prototype</a></li><li><a href="#object.hasownproperty"><code>hasOwnProperty</code></a></li><li><a href="#object.forinloop">The <code>for in</code> Loop</a></li></ul></li><li class="nav_function"><h1><a href="#function">函式</a></h1><ul><li><a href="#function.general">函式的宣告和表達方式</a></li><li><a href="#function.this"><code>this</code> 的工作原理</a></li><li><a href="#function.closures">Closures 和 References</a></li><li><a href="#function.arguments"><code>arguments</code> 物件</a></li><li><a href="#function.constructors">建構函式</a></li><li><a href="#function.scopes">作用域和命名空間</a></li></ul></li><li class="nav_array"><h1><a href="#array">陣列</a></h1><ul><li><a href="#array.general">Array 迴圈和屬性</a></li><li><a href="#array.constructor"><code>Array</code> 的建構函式</a></li></ul></li><li class="nav_types"><h1><a href="#types">類型</a></h1><ul><li><a href="#types.equality">Equality and Comparisons</a></li><li><a href="#types.typeof">The <code>typeof</code> Operator</a></li><li><a href="#types.instanceof">The <code>instanceof</code> Operator</a></li><li><a href="#types.casting">Type Casting</a></li></ul></li><li class="nav_core"><h1><a href="#core">核心</a></h1><ul><li><a href="#core.eval">為什麼不要使用 <code>eval</code></a></li><li><a href="#core.undefined"><code>undefined</code> 和 <code>null</code></a></li><li><a href="#core.semicolon">自動插入分號</a></li><li><a href="#core.delete">The <code>delete</code> Operator</a></li></ul></li><li class="nav_other"><h1><a href="#other">其他</a></h1><ul><li><a href="#other.timeouts"><code>setTimeout</code> and <code>setInterval</code></a></li></ul></li></ul></nav><!-- Mobile navigation--><nav id="nav_mobile"><a id="nav_prev_section" href="#">prev section<span class="nav_section_name">section name</span></a><a id="nav_next_section" href="#">next section<span class="nav_section_name">section name</span></a><a id="show_menu">show menu</a></nav><!-- Sections--><section id="intro"><!-- Introduction--><header id="intro.intro"><h1>簡介</h1><div><p><strong>JavaScript Garden</strong> is a growing collection of documentation about the most 
quirky parts of the JavaScript programming language. It gives advice to 
avoid common mistakes and subtle bugs, as well as performance issues and bad 
practices, that non-expert JavaScript programmers may encounter on their 
endeavours into the depths of the language.</p>

<p>JavaScript Garden does <strong>not</strong> aim to teach you JavaScript. Former knowledge
of the language is strongly recommended in order to understand the topics covered
in this guide. In order to learn the basics of the language, please head over to 
the excellent <a href="https://developer.mozilla.org/en/JavaScript/Guide">guide</a> on the Mozilla Developer Network.</p>

<h2>The Authors</h2>

<p>This guide is the work of two lovely <a href="http://stackoverflow.com/">Stack Overflow</a> users, <a href="http://stackoverflow.com/users/170224/ivo-wetzel">Ivo Wetzel</a>
(Writing) and <a href="http://stackoverflow.com/users/313758/yi-jiang">Zhang Yi Jiang</a> (Design).</p>

<h2>Contributors</h2>

<ul>
<li><a href="https://github.com/caio">Caio Romão</a> (Spelling corrections)</li>
<li><a href="https://github.com/blixt">Andreas Blixt</a> (Language corrections)</li>
</ul>

<h2>Hosting</h2>

<p>JavaScript Garden is hosted on GitHub, but <a href="http://cramerdev.com/">Cramer Development</a> supports us
with a mirror at <a href="http://javascriptgarden.info/">JavaScriptGarden.info</a>.</p>

<h2>License</h2>

<p>JavaScript Garden is published under the <a href="https://github.com/BonsaiDen/JavaScript-Garden/blob/next/LICENSE">MIT license</a> and hosted on
<a href="https://github.com/BonsaiDen/JavaScript-Garden">GitHub</a>. If you find errors or typos please <a href="https://github.com/BonsaiDen/JavaScript-Garden/issues">file an issue</a> or a pull 
request on the repository. You can also find us in the <a href="http://chat.stackoverflow.com/rooms/17/javascript">JavaScript room</a> on
Stack Overflow chat.</p></div></header><!-- Articles--></section><section id="object"><!-- Introduction--><header id="object.intro"><h1>物件</h1></header><!-- Articles--><article id="object.general"><h2>Object Usage and Properties</h2><div><p>Everything in JavaScript acts like an object, with the only two exceptions being 
<a href="#core.undefined"><code>null</code></a> and <a href="#core.undefined"><code>undefined</code></a>.</p>

<pre><code>false.toString(); // &#39;false&#39;
[1, 2, 3].toString(); // &#39;1,2,3&#39;

function Foo(){}
Foo.bar = 1;
Foo.bar; // 1
</code></pre>

<p>A common misconception is that number literals cannot be used as
objects. That is because a flaw in JavaScript&#39;s parser tries to parse the <em>dot 
notation</em> on a number as a floating point literal.</p>

<pre><code>2.toString(); // raises SyntaxError
</code></pre>

<p>There are a couple of workarounds that can be used to make number literals act
as objects too.</p>

<pre><code>2..toString(); // the second point is correctly recognized
2 .toString(); // note the space left to the dot
(2).toString(); // 2 is evaluated first
</code></pre>

</div><div><h3>Objects as a Data Type</h3>

<p>Objects in JavaScript can also be used as <a href="http://en.wikipedia.org/wiki/Hashmap"><em>Hashmaps</em></a>; they mainly consist 
of named properties mapping to values.</p>

<p>Using an object literal - <code>{}</code> notation - it is possible to create a 
plain object. This new object <a href="#object.prototype">inherits</a> from <code>Object.prototype</code> and 
does not have <a href="#object.hasownproperty">own properties</a> defined.</p>

<pre><code>var foo = {}; // a new empty object

// a new object with a &#39;test&#39; property with value 12
var bar = {test: 12}; 
</code></pre>

</div><div><h3>Accessing Properties</h3>

<p>The properties of an object can be accessed in two ways, via either the dot
notation or the square bracket notation.</p>

<pre><code>var foo = {name: &#39;kitten&#39;}
foo.name; // kitten
foo[&#39;name&#39;]; // kitten

var get = &#39;name&#39;;
foo[get]; // kitten

foo.1234; // SyntaxError
foo[&#39;1234&#39;]; // works
</code></pre>

<p>The notations work almost identically, with the only difference being that the
square bracket notation allows for dynamic setting of properties and
the use of property names that would otherwise lead to a syntax error.</p>

</div><div><h3>Deleting Properties</h3>

<p>The only way to remove a property from an object is to use the <code>delete</code>
operator; setting the property to <code>undefined</code> or <code>null</code> only removes the
<em>value</em> associated with the property, but not the <em>key</em>.</p>

<pre><code>var obj = {
    bar: 1,
    foo: 2,
    baz: 3
};
obj.bar = undefined;
obj.foo = null;
delete obj.baz;

for(var i in obj) {
    if (obj.hasOwnProperty(i)) {
        console.log(i, &#39;&#39; + obj[i]);
    }
}
</code></pre>

<p>The above outputs both <code>bar undefined</code> and <code>foo null</code> - only <code>baz</code> was
removed and is therefore missing from the output.</p>

</div><div><h3>Notation of Keys</h3>

<pre><code>var test = {
    &#39;case&#39;: &#39;I am a keyword, so I must be notated as a string&#39;,
    delete: &#39;I am a keyword, so me too&#39; // raises SyntaxError
};
</code></pre>

<p>Object properties can be both notated as plain characters and as strings. Due to
another mis-design in JavaScript&#39;s parser, the above will throw 
a <code>SyntaxError</code> prior to ECMAScript 5.</p>

<p>This error arises from the fact that <code>delete</code> is a <em>keyword</em>; therefore, it must be 
notated as a <em>string literal</em> to ensure that it will be correctly interpreted by
older JavaScript engines.</p></div></article><article id="object.prototype"><h2>The Prototype</h2><div><p>JavaScript does not feature a classical inheritance model; instead, it uses a 
<em>prototypal</em> one. </p>

<p>While this is often considered to be one of JavaScript&#39;s weaknesses, the 
prototypal inheritance model is in fact more powerful than the classic model.
It is, for example, fairly trivial to build a classic model on top of a
prototypal model, while the other way around is a far more difficult task.</p>

<p>JavaScript is the only widely used language that features prototypal
inheritance, so it can take time to adjust to the differences between the two
models. </p>

<p>The first major difference is that inheritance in JavaScript uses <em>prototype
chains</em>.</p>

<aside>
  <p><strong>Note:</strong> Simply using <code>Bar.prototype = Foo.prototype</code> will result in both objects
  sharing the <strong>same</strong> prototype. Therefore, changes to either object&#39;s prototype 
  will affect the prototype of the other as well, which in most cases is not the 
  desired effect.</p>
</aside>

<pre><code>function Foo() {
    this.value = 42;
}
Foo.prototype = {
    method: function() {}
};

function Bar() {}

// Set Bar&#39;s prototype to a new instance of Foo
Bar.prototype = new Foo();
Bar.prototype.foo = &#39;Hello World&#39;;

// Make sure to list Bar as the actual constructor
Bar.prototype.constructor = Bar;

var test = new Bar() // create a new bar instance

// The resulting prototype chain
test [instance of Bar]
    Bar.prototype [instance of Foo] 
        { foo: &#39;Hello World&#39; }
        Foo.prototype
            { method: ... }
            Object.prototype
                { toString: ... /* etc. */ }
</code></pre>

<p>In the code above, the object <code>test</code> will inherit from both <code>Bar.prototype</code> and
<code>Foo.prototype</code>; hence, it will have access to the function <code>method</code> that was 
defined on <code>Foo</code>. It will also have access to the property <code>value</code> of the
<strong>one</strong> <code>Foo</code> instance that is its prototype. It is important to note that <code>new
Bar()</code> does <strong>not</strong> create a new <code>Foo</code> instance, but reuses the one assigned to 
its prototype; thus, all <code>Bar</code> instances will share the <strong>same</strong> <code>value</code> property.</p>

<aside>
  <p><strong>Note:</strong> Do <strong>not</strong> use <code>Bar.prototype = Foo</code>, since it will not point to 
  the prototype of <code>Foo</code> but rather to the function object <code>Foo</code>. So the 
  prototype chain will go over <code>Function.prototype</code> and not <code>Foo.prototype</code>;
  therefore, <code>method</code> will not be on the prototype chain.</p>
</aside>

</div><div><h3>Property Lookup</h3>

<p>When accessing the properties of an object, JavaScript will traverse the
prototype chain <strong>upwards</strong> until it finds a property with the requested name.</p>

<p>If it reaches the top of the chain - namely <code>Object.prototype</code> - and still
hasn&#39;t found the specified property, it will return the value
<a href="#core.undefined">undefined</a> instead.</p>

</div><div><h3>The Prototype Property</h3>

<p>While the prototype property is used by the language to build the prototype
chains, it is still possible to assign <strong>any</strong> given value to it. However, 
primitives will simply get ignored when assigned as a prototype.</p>

<pre><code>function Foo() {}
Foo.prototype = 1; // no effect
</code></pre>

<p>Assigning objects, as shown in the example above, will work, and allows for dynamic
creation of prototype chains.</p>

</div><div><h3>Performance</h3>

<p>The lookup time for properties that are high up on the prototype chain can have
a negative impact on performance, and this may be significant in code where
performance is critical. Additionally, trying to access non-existent properties
will always traverse the full prototype chain. </p>

<p>Also, when <a href="#object.forinloop">iterating</a> over the properties of an object 
<strong>every</strong> property that is on the prototype chain will be enumerated.</p>

</div><div><h3>Extension of Native Prototypes</h3>

<p>One mis-feature that is often used is to extend <code>Object.prototype</code> or one of the
other built in prototypes.</p>

<p>This technique is called <a href="http://en.wikipedia.org/wiki/Monkey_patch">monkey patching</a> and breaks <em>encapsulation</em>. While 
used by popular frameworks such as <a href="http://prototypejs.org/">Prototype</a>, there is still no good 
reason for cluttering built-in types with additional <em>non-standard</em> functionality.</p>

<p>The <strong>only</strong> good reason for extending a built-in prototype is to backport 
the features of newer JavaScript engines; for example, 
<a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach"><code>Array.forEach</code></a>.</p>

</div><div><h3>In Conclusion</h3>

<p>It is <strong>essential</strong> to understand the prototypal inheritance model before
writing complex code that makes use of it. Also, be aware of the length of the
prototype chains in your code and break them up if necessary to avoid possible
performance problems. Further, the native prototypes should <strong>never</strong> be
extended unless it is for the sake of compatibility with newer JavaScript
features.</p></div></article><article id="object.hasownproperty"><h2><code>hasOwnProperty</code></h2><div><p>To check whether an object has a property defined on <em>itself</em> and not somewhere
on its <a href="#object.prototype">prototype chain</a>, it is necessary to use the
<code>hasOwnProperty</code> method which all objects inherit from <code>Object.prototype</code>.</p>

<aside>
  <p><strong>Note:</strong> It is <strong>not</strong> enough to check whether a property is <code>undefined</code>. The
  property might very well exist, but its value just happens to be set to 
  <code>undefined</code>.</p>
</aside>

<p><code>hasOwnProperty</code> is the only thing in JavaScript which deals with properties and 
does <strong>not</strong> traverse the prototype chain.</p>

<pre><code>// Poisoning Object.prototype
Object.prototype.bar = 1; 
var foo = {goo: undefined};

foo.bar; // 1
&#39;bar&#39; in foo; // true

foo.hasOwnProperty(&#39;bar&#39;); // false
foo.hasOwnProperty(&#39;goo&#39;); // true
</code></pre>

<p>Only <code>hasOwnProperty</code> will give the correct and expected result; this is 
essential when iterating over the properties of any object. There is <strong>no</strong> other 
way to exclude properties that are not defined on the object itself, but 
somewhere on its prototype chain.  </p>

</div><div><h3><code>hasOwnProperty</code> as a Property</h3>

<p>JavaScript does not protect the property name <code>hasOwnProperty</code>; thus, if the
possibility exists that an object might have a property with this name, it is
necessary to use an <em>external</em> <code>hasOwnProperty</code> to get correct results.</p>

<pre><code>var foo = {
    hasOwnProperty: function() {
        return false;
    },
    bar: &#39;Here be dragons&#39;
};

foo.hasOwnProperty(&#39;bar&#39;); // always returns false

// Use another Object&#39;s hasOwnProperty and call it with &#39;this&#39; set to foo
({}).hasOwnProperty.call(foo, &#39;bar&#39;); // true

// It&#39;s also possible to use the hasOwnProperty property from the Object property for this purpose
Object.prototype.hasOwnProperty.call(obj, &#39;bar&#39;); // true
</code></pre>

</div><div><h3>In Conclusion</h3>

<p>Using <code>hasOwnProperty</code> is the <strong>only</strong> reliable method to check for the
existence of a property on an object. It is recommended that <code>hasOwnProperty</code>
is used in <strong>every</strong> <a href="#object.forinloop"><code>for in</code> loop</a> to avoid errors from
extended native <a href="#object.prototype">prototypes</a>.</p></div></article><article id="object.forinloop"><h2>The <code>for in</code> Loop</h2><div><p>Just like the <code>in</code> operator, the <code>for in</code> loop traverses the prototype
chain when iterating over the properties of an object.</p>

<aside>
  <p><strong>Note:</strong> The <code>for in</code> loop will <strong>not</strong> iterate over any properties that 
  have their <code>enumerable</code> attribute set to <code>false</code>; for example, the <code>length</code> 
  property of an array.</p>
</aside>

<pre><code>// Poisoning Object.prototype
Object.prototype.bar = 1;

var foo = {moo: 2};
for(var i in foo) {
    console.log(i); // prints both bar and moo
}
</code></pre>

<p>Since it is not possible to change the behavior of the <code>for in</code> loop itself, it
is necessary to filter out the unwanted properties inside the loop body; 
this is done using the <a href="#object.hasownproperty"><code>hasOwnProperty</code></a> method of 
<code>Object.prototype</code>.</p>

<aside>
  <p><strong>Note:</strong> Since <code>for in</code> always traverses the complete prototype chain, it
  will get slower with each additional layer of inheritance added to an object.</p>
</aside>

</div><div><h3>Using <code>hasOwnProperty</code> for Filtering</h3>

<pre><code>// still the foo from above
for(var i in foo) {
    if (foo.hasOwnProperty(i)) {
        console.log(i);
    }
}
</code></pre>

<p>This version is the only correct one to use. Due to the use of <code>hasOwnProperty</code>, it
will <strong>only</strong> print out <code>moo</code>. When <code>hasOwnProperty</code> is left out, the code is 
prone to errors in cases where the native prototypes - e.g. <code>Object.prototype</code> - 
have been extended.</p>

<p>One widely used framework that extends <code>Object.prototype</code> is <a href="http://www.prototypejs.org/">Prototype</a>.
When this framework is included, <code>for in</code> loops that do not use
<code>hasOwnProperty</code> are guaranteed to break.</p>

</div><div><h3>In Conclusion</h3>

<p>It is recommended to <strong>always</strong> use <code>hasOwnProperty</code>. Assumptions should never
be made about the environment the code is running in, or whether the native
prototypes have been extended or not.</p></div></article></section><section id="function"><!-- Introduction--><header id="function.intro"><h1>函式</h1></header><!-- Articles--><article id="function.general"><h2>函式的宣告和表達方式</h2><div><p>函式在 JavaScript 是第一等物件。這表示他們可以把函式當做值一樣傳遞。
一個常見的用法是用 <em>匿名函式</em> 當做一個回傳去呼叫另一個函式，這是一種非同步函式</p>

</div><div><h3>函式的宣告</h3>

<pre><code>function foo() {}
</code></pre>

<p>上面的函式在被執行之前會被 <a href="#function.scopes">解析(hoisted)</a>，因此它可以在 <strong>任意</strong> 的地方都是 <em>有宣告的</em> ，就算是在比這個函式還早呼叫。</p>

<pre><code>foo(); // 可以執行，因為 foo 已經在運行前就被建立
function foo() {}
</code></pre>

</div><div><h3><code>function</code> 的表達式</h3>

<pre><code>var foo = function() {};
</code></pre>

<p>這個例子把一個 <em>匿名</em> 函式賦值給變數 <code>foo</code>。</p>

<pre><code>foo; // &#39;undefined&#39;
foo(); // 錯誤: TypeError
var foo = function() {};
</code></pre>

<p>由於 <code>var</code> 已經宣告變數 <code>foo</code> 在所有的程式碼執行之前。
所以 <code>foo</code>已經在程式運行前就已經被定義過了。
但是因為賦值只會在運行時去職情，所以在程式碼執行前，<code>foo</code> 的值還沒被宣告所以為 <a href="#core.undefined">undefined</a>。</p>

</div><div><h3>命名函式的賦值表達式</h3>

<p>另一個特殊狀況就勢將一個命名函式賦值給一個變數。</p>

<pre><code>var foo = function bar() {
    bar(); // 可以運行
}
bar(); // 錯誤：ReferenceError
</code></pre>

<p><code>bar</code> 不可以在外部的區域被執行，因為它只有在 <code>foo</code> 的函式內才可以去執行。
然而在 <code>bar</code> 內部還是可以看見。這是由於 JavaScript的 <a href="#function.scopes">命名處理</a>所致。
函式名在函式內 <em>都</em> 可以去使用。</p></div></article><article id="function.this"><h2><code>this</code> 的工作原理</h2><div><p>JavaScript 有移到完全部屬於其他語言處理 <code>this</code> 的處理機制。
在 <strong>五</strong> 種物同的情況下， <code>this</code> 指向的個不相同</p>

</div><div><h3>全域變數</h3>

<pre><code>this;
</code></pre>

<p>如果再全域範圍內使用 <code>this</code>，會指向 <em>全域</em> 的物件</p>

</div><div><h3>呼叫一個函式</h3>

<pre><code>foo();
</code></pre>

<p>這裡 <code>this</code> 也會指向 <em>全域</em> 對象。</p>

<aside class="es5"><p><strong>ES5 注意:</strong> 在嚴格模式下，不存在全域變數。
  <code>this</code> 將會是 <code>undefined</code>。</p>
</aside>

</div><div><h3>方法調用</h3>

<pre><code>test.foo(); 
</code></pre>

<p>這個例子中， <code>this</code> 指向 <code>test</code> 物件。</p>

</div><div><h3>呼叫一個建構函式</h3>

<pre><code>new foo(); 
</code></pre>

<p>如果函式傾向用 <code>new</code> 關鍵詞使用，我們稱這個函式為 <a href="#function.constructors">建構函式</a>。
在函式內部， <code>this</code> 指向 <em>新物件的創立</em></p>

</div><div><h3>顯示的設置 <code>this</code></h3>

<pre><code>function foo(a, b, c) {}

var bar = {};
foo.apply(bar, [1, 2, 3]); // Array 會被擴展，如下所示
foo.call(bar, 1, 2, 3); // 傳遞參數 a = 1, b = 2, c = 3
</code></pre>

<p>當使用 <code>function.prototype</code> 上的 <code>call</code> 或只 <code>apply</code> 方法時，函式內的 <code>this</code> 將會被 <strong>顯示設置</strong> 為函式調用的第一個參數。</p>

<p>As a result, in the above example the <em>method case</em> does <strong>not</strong> apply, and <code>this</code> 
inside of <code>foo</code> will be set to <code>bar</code>.</p>

<aside>
  <p><strong>Note:</strong> <code>this</code> <strong>cannot</strong> be used to refer to the object inside of an <code>Object</code>
  literal. So <code>var obj = {me: this}</code> will <strong>not</strong> result in <code>me</code> referring to
  <code>obj</code>, since <code>this</code> only gets bound by one of the five listed cases.</p>
</aside>

</div><div><h3>常見誤解</h3>

<p>While most of these cases make sense, the first can be considered another
mis-design of the language because it <strong>never</strong> has any practical use.</p>

<pre><code>Foo.method = function() {
    function test() {
        // this is set to the global object
    }
    test();
}
</code></pre>

<p>A common misconception is that <code>this</code> inside of <code>test</code> refers to <code>Foo</code>; while in
fact, it <strong>does not</strong>.</p>

<p>In order to gain access to <code>Foo</code> from within <code>test</code>, it is necessary to create a 
local variable inside of <code>method</code> that refers to <code>Foo</code>.</p>

<pre><code>Foo.method = function() {
    var that = this;
    function test() {
        // Use that instead of this here
    }
    test();
}
</code></pre>

<p><code>that</code> is just a normal variable name, but it is commonly used for the reference to an 
outer <code>this</code>. In combination with <a href="#function.closures">closures</a>, it can also 
be used to pass <code>this</code> values around.</p>

</div><div><h3>Assigning Methods</h3>

<p>Another thing that does <strong>not</strong> work in JavaScript is function aliasing, which is
<strong>assigning</strong> a method to a variable.</p>

<pre><code>var test = someObject.methodTest;
test();
</code></pre>

<p>Due to the first case, <code>test</code> now acts like a plain function call; therefore,
<code>this</code> inside it will no longer refer to <code>someObject</code>.</p>

<p>While the late binding of <code>this</code> might seem like a bad idea at first, in 
fact, it is what makes <a href="#object.prototype">prototypal inheritance</a> work. </p>

<pre><code>function Foo() {}
Foo.prototype.method = function() {};

function Bar() {}
Bar.prototype = Foo.prototype;

new Bar().method();
</code></pre>

<p>When <code>method</code> gets called on an instance of <code>Bar</code>, <code>this</code> will now refer to that
very instance. </p></div></article><article id="function.closures"><h2>Closures 和 References</h2><div><p>JavaScript 有一個很重要的特徵就是 <strong>closures</strong>
因為有 Closures，所以作用域 <strong>永遠</strong> 能夠去訪問作用區間外面的變數。
<a href="#function.scopes">函數區間</a> 是JavaScript 中唯一擁有自生作用域的結構，因此 Closures 的創立需要依賴函數</p>

</div><div><h3>模仿私有變數</h3>

<pre><code>function Counter(start) {
    var count = start;
    return {
        increment: function() {
            count++;
        },

        get: function() {
            return count;
        }
    }
}

var foo = Counter(4);
foo.increment();
foo.get(); // 5
</code></pre>

<p>這裡，<code>Counter</code> 返回兩個 Closures，函數 <code>increment</code> 還有 <code>get</code>。這兩個函數都維持著對外部作用域 <code>Counter</code> 的引用，因此總可以訪問作用域的變數 <code>count</code>。</p>

</div><div><h3>為什麼不可以在外部訪問私有變數</h3>

<p>因為 Javascript <strong>不可以</strong> 對作用域進行引用或賦值。因此外部的地方沒有辦法訪問 <code>count</code> 變數。
唯一的途徑就是經過那兩個 Closures</p>

<pre><code>var foo = new Counter(4);
foo.hack = function() {
    count = 1337;
};
</code></pre>

<p>在上面的例子中 <code>count</code> <strong>不會</strong> 改變到 <code>Counter</code> 裡面的 <code>count</code> 的值。因為 <code>foo.hack</code> 沒有在 <strong>那個</strong> 作用域內被宣告。它只有會覆蓋或者建立在一個 <strong>全域</strong> 的變數 <code>count</code></p>

</div><div><h3>在循環內的 Closures</h3>

<p>一個常見的錯誤就是在 Closures 中使用迴圈，假設我們要使用每次迴圈中所使用的進入變數</p>

<pre><code>for(var i = 0; i &lt; 10; i++) {
    setTimeout(function() {
        console.log(i);  
    }, 1000);
}
</code></pre>

<p>在上面的例子中它 <strong>不會</strong> 輸出數字從 <code>0</code> 到 <code>9</code>，但只會出現數字 <code>10</code> 十次。
在 <code>console.log</code> 被呼叫的時候，這個 <em>匿名</em> 函數中保持一個 <strong>參考</strong> 到 i ，此時 <code>for</code>迴圈已經結束， <code>i</code> 的值被修改成了 <code>10</code>。
為了要達到想要的結果，需要在每次創造 <strong>副本</strong> 來儲存 <code>i</code> 的變數。</p>

</div><div><h3>避免引用錯誤</h3>

<p>為了要有達到正確的效果，最好是把它包在一個
<a href="#function.scopes">匿名函數</a>.</p>

<pre><code>for(var i = 0; i &lt; 10; i++) {
    (function(e) {
        setTimeout(function() {
            console.log(e);  
        }, 1000);
    })(i);
}
</code></pre>

<p>匿名外部的函數被呼叫，並把 <code>i</code> 作為它第一個參數，此時函數內 <code>e</code> 變數就擁有了一個 <code>i</code> 的拷貝。
當傳遞給 <code>setTimeout</code> 這個匿名函數執行時，它就擁有了對 <code>e</code> 的引用，而這個值 <strong>不會</strong> 被循環改變。
另外有一個方法也可以完成這樣的工作，那就是在匿名函數中返回一個函數，這和上面的程式碼有同樣的效果。</p>

<pre><code>for(var i = 0; i &lt; 10; i++) {
    setTimeout((function(e) {
        return function() {
            console.log(e);
        }
    })(i), 1000)
}
</code></pre></div></article><article id="function.arguments"><h2><code>arguments</code> 物件</h2><div><p>所有函數在 JavaScript 中都可以有個特別的參數 <code>arguments</code>。
這個變數掌握了一列傳入函數中的參數</p>

<aside>
  <p><strong>注意:</strong> 由於 <code>arguments</code> 都已經在函數中被定義了
  經過 <code>var</code> 定義或是用 <code>arguments</code> 宣告參數
  <code>arguments</code> 物件都不會被建立</p>
</aside>

<p><code>arguments</code> 物件 <strong>不是</strong> 一個 <code>Array</code>，雖然都有很多 Array 的語法 - 就像是 <code>length</code> 屬性 - 但是它沒有繼承來自 <code>Array.prototype</code> 事實上它繼承 <code>object</code>。</p>

<p>由於這些原因，這 <strong>不可能</strong> 用 Array 的一些功能像是 <code>push</code>、<code>pop</code>或是 <code>slice</code> 在 <code>arguments</code>。
但是像 <code>for</code> 迴圈這些迴圈都是可以用的，如果真的需要使用一些標準的 <code>Array</code> 功能可以先把它轉成真的 <code>Array</code> 再去使用。</p>

</div><div><h3>轉為 Array</h3>

<p>下面的程式可以回傳一個新的 <code>Array</code> 包含所有的元素在 <code>Arguments</code>的物件中</p>

<pre><code>Array.prototype.slice.call(arguments);
</code></pre>

<p>這種轉化方式比較 <strong>慢</strong> ，不建議使用這種作法如果再追求效率的程式中。</p>

</div><div><h3>傳遞參數</h3>

<p>下面是建議用這種方式去傳參數到另一個函數</p>

<pre><code>function foo() {
    bar.apply(null, arguments);
}
function bar(a, b, c) {
    // 在這裡做一些事情
}
</code></pre>

<p>另一個技巧是用 <code>call</code> 和 <code>apply</code> 放在一起來創造一個更快的解綁定包裝器</p>

<pre><code>function Foo() {}

Foo.prototype.method = function(a, b, c) {
    console.log(this, a, b, c);
};

// Create an unbound version of "method" 
// 輸入的參數: this, arg1, arg2...argN
Foo.method = function() {

    // 結果: Foo.prototype.method.call(this, arg1, arg2... argN)
    Function.call.apply(Foo.prototype.method, arguments);
};
</code></pre>

</div><div><h3>自動更新</h3>

<p>在 <code>Arguments</code> 物件創造的 <em>getter</em> 和 <em>setter</em> 的函數方法，可以被視為原本函數的變數。</p>

<p>因此，改變了一個變數會跟著改變它的值而且也間接的改變稻香對應的 <code>arguments</code> 的物件，反之亦然。</p>

<pre><code>function foo(a, b, c) {
    arguments[0] = 2;
    a; // 2

    b = 4;
    arguments[1]; // 4

    var d = c;
    d = 9;
    c; // 3
}
foo(1, 2, 3);
</code></pre>

</div><div><h3>性能</h3>

<p><code>arguments</code> 總是會被宣告，但除了兩個情況，一個是在一個函式中或是在其中一個參入。而不論他是否有被使用。</p>

<p><em>getters</em> 和 <em>setter</em> 會永遠被創造。然而，他們對任何性能都沒有影響，除非對它的屬性有多次的訪問</p>

<aside class="es5"><p><strong>ES5 提示:</strong> 那些 <em>getters</em> 和 <em>setters</em> 在嚴格的模式像不會被建立</p>
</aside>

<p>然而會有一種情況來降低 JavaScript 引擎的效能。就是使用 <code>arguments.callee</code>。</p>

<pre><code>function foo() {
    arguments.callee; // 做一些在這個函數物件
    arguments.callee.caller; // 然後呼叫這個函數物件
}

function bigLoop() {
    for(var i = 0; i &lt; 100000; i++) {
        foo(); // 通常會在內聯
    }
}
</code></pre>

<p>在上面的程式中， <code>foo</code> 不再是一個單存的互聯函數
因為它需要知道他自己和它的調用者。
這不僅減低了它的性能，而且還破壞的封裝</p>

<p><strong>強烈建議不要使用</strong>  <code>arguments.callee</code> 或是其他它的屬性</p>

<aside class="es5"><p><strong>ES5 Note:</strong> 在嚴格的模式下 <code>arguments.callee</code> 會丟出一個 <code>TypeError</code>， 因為這種方法已經被廢除了</p>
</aside></div></article><article id="function.constructors"><h2>建構函式</h2><div><p>JavaScript 中的建構函式和其他語言中的建構函式是不同的。
用 <code>new</code> 的關鍵字方式調用的函式都被認為是建構函式。
在建構函式內部 - 被呼叫的函式 - <code>this</code> 指向一個新建立的 <code>object</code>。<a href="#object.prototype">prototype</a> 這是一個新的物件一個被指向函式的 <code>prototype</code> 的建構函式。</p>

<p>If the function that was called has no explicit <code>return</code> statement, then it
implicitly returns the value of <code>this</code> - the new object. 
如果被使用的函式沒有明顯的呼叫 <code>return</code> 的表達式，它會回傳一個隱性的 <code>this</code> 的新物件。</p>

<pre><code>function Foo() {
    this.bla = 1;
}

Foo.prototype.test = function() {
    console.log(this.bla);
};

var test = new Foo();
</code></pre>

<p>在上面的例子中 <code>Foo</code> 建立一個建構函式，並設立一個 <code>prototype</code> 來創建一個新的物件叫 <code>Foo.prototype</code>。
這個情況下它顯示的 <code>return</code> 一個表達式，但他 <strong>只</strong> 返回一個 <code>Object</code>。</p>

<pre><code>function Bar() {
    return 2;
}
new Bar(); // 返回一個新物件

function Test() {
    this.value = 2;

    return {
        foo: 1
    };
}
new Test(); // 回傳物件
</code></pre>

<p>如果 <code>new</code> 的關鍵字被忽略，函式就 <strong>不會</strong> 回傳一個新的物件。</p>

<pre><code>function Foo() {
    this.bla = 1; // 獲取一個全域的參數
}
Foo(); // undefined
</code></pre>

<p>雖然上面有些情況也能正常運行，但是由於 JavaScript 中 <a href="#funciton.this"><code>this</code></a> 的工作原理，這裡的 <code>this</code> 指向 <em>全域對象</em>。</p>

</div><div><h3>工廠模式</h3>

<p>為了不使用 <code>new</code> 關鍵字，建構函式必須顯性的返回一個值。</p>

<pre><code>function Bar() {
    var value = 1;
    return {
        method: function() {
            return value;
        }
    }
}
Bar.prototype = {
    foo: function() {}
};

new Bar();
Bar();
</code></pre>

<p>上面兩個呼叫 <code>Bar</code> 的方法回傳的值都一樣，一個新創建的擁有 <code>method</code> 屬性被返回，這裡創建了一個 <a href="#function.closures">Closure</a>.</p>

<p>還有注意， <code>new Bar()</code> 並 <strong>不會</strong> 改變返回物件的原型。
因為建構函式的原型會指向剛剛創立的新物件，而在這裡的 <code>Bar</code> 沒有把這個新物件返回。
在上面的例子中，使用或者不使用 <code>new</code> 關鍵字沒有什麼功能性的區別</p>

</div><div><h3>通過工廠模式創建的新對象</h3>

<p>常聽到建議 <strong>不要</strong> 使用 <code>new</code>，因為如果忘記如何使用它會造成錯誤。
為了創建一個新的物件，我們可以用工廠方法，來創造一個新的物件在那個方法中。</p>

<pre><code>function Foo() {
    var obj = {};
    obj.value = &#39;blub&#39;;

    var private = 2;
    obj.someMethod = function(value) {
        this.value = value;
    }

    obj.getPrivate = function() {
        return private;
    }
    return obj;
}
</code></pre>

<p>雖然上面的方式比起 <code>new</code> 的調用方式更不容易出錯，並且可以充分的使用 <a href="#function.closures">私有變數</a>所帶來的便利，但是還是有一些不好的地方</p>

<ol>
<li>會占用更多的記憶體，因為創建的物件 <strong>沒有</strong> 辦法放在在同一個原型上。</li>
<li>為了要用繼承的方式，工廠方法需要複製所有的屬性或是把一個物件作為新的物件的原型。</li>
<li>放棄原型鏈僅僅是因為防止遺漏 <code>new</code> 所帶來的問題，這與語言本身的思想鄉違背。</li>
</ol>

</div><div><h3>結語</h3>

<p>雖然遺漏 <code>new</code> 關鍵字可能會導致問題，但這並 <strong>不是</strong> 放棄只用原型的藉口。
最終使用哪種方式取決於應用程式的需求，選擇一種程式語言風格並堅持下去才是最重要的。</p></div></article><article id="function.scopes"><h2>作用域和命名空間</h2><div><p>儘管 JavaScript 支持一個大括號創建的程式碼，但並不支持塊級作用域。
而僅僅支援 <em>函式作用域</em></p>

<pre><code>function test() { // 一個作用域
    for(var i = 0; i &lt; 10; i++) { // 不是一個作用域
        // 算數
    }
    console.log(i); // 10
}
</code></pre>

<aside>
  <p><strong>Note:</strong> When not used in an assignment, return statement or as a function 
  argument, the <code>{...}</code> notation will get interpreted as a block statement and 
  <strong>not</strong> as an object literal. This, in conjunction with 
  <a href="#core.semicolon">automatic insertion of semicolons</a>, can lead to subtle errors.</p>
</aside>

<p>There are also no distinct namespaces in JavaScript, which means that everything 
gets defined in one <em>globally shared</em> namespace.</p>

<p>Each time a variable is referenced, JavaScript will traverse upwards through all 
the scopes until it finds it. In the case that it reaches the global scope and 
still has not found the requested name, it will raise a <code>ReferenceError</code>.</p>

</div><div><h3>全域變數的壞處</h3>

<pre><code>// script A
foo = &#39;42&#39;;

// script B
var foo = &#39;42&#39;
</code></pre>

<p>The above two scripts do <strong>not</strong> have the same effect. Script A defines a 
variable called <code>foo</code> in the <em>global</em> scope, and script B defines a <code>foo</code> in the
<em>current</em> scope.</p>

<p>Again, that is <strong>not</strong> at all the <em>same effect</em>: not using <code>var</code> can have major 
implications.</p>

<pre><code>// global scope
var foo = 42;
function test() {
    // local scope
    foo = 21;
}
test();
foo; // 21
</code></pre>

<p>Leaving out the <code>var</code> statement inside the function <code>test</code> will override the 
value of <code>foo</code>. While this might not seem like a big deal at first, having 
thousands of lines of JavaScript and not using <code>var</code> will introduce horrible,
hard-to-track-down bugs.</p>

<pre><code>// global scope
var items = [/* some list */];
for(var i = 0; i &lt; 10; i++) {
    subLoop();
}

function subLoop() {
    // scope of subLoop
    for(i = 0; i &lt; 10; i++) { // missing var statement
        // do amazing stuff!
    }
}
</code></pre>

<p>The outer loop will terminate after the first call to <code>subLoop</code>,  since <code>subLoop</code>
overwrites the global value of <code>i</code>. Using a <code>var</code> for the second <code>for</code> loop would
have easily avoided this error. The <code>var</code> statement should <strong>never</strong> be left out 
unless the <em>desired effect</em> is to affect the outer scope.</p>

</div><div><h3>Local Variables</h3>

<p>The only source for local variables in JavaScript are
<a href="#function.general">function</a> parameters and variables declared via the 
<code>var</code> statement.</p>

<pre><code>// global scope
var foo = 1;
var bar = 2;
var i = 2;

function test(i) {
    // local scope of the function test
    i = 5;

    var foo = 3;
    bar = 4;
}
test(10);
</code></pre>

<p>While <code>foo</code> and <code>i</code> are local variables inside the scope of the function <code>test</code>,
the assignment of <code>bar</code> will override the global variable with the same name.</p>

</div><div><h3>Hoisting</h3>

<p>JavaScript <strong>hoists</strong> declarations. This means that both <code>var</code> statements and
<code>function</code> declarations will be moved to the top of their enclosing scope.</p>

<pre><code>bar();
var bar = function() {};
var someValue = 42;

test();
function test(data) {
    if (false) {
        goo = 1;

    } else {
        var goo = 2;
    }
    for(var i = 0; i &lt; 100; i++) {
        var e = data[i];
    }
}
</code></pre>

<p>The above code gets transformed before execution starts. JavaScript moves
the <code>var</code> statements, as well as <code>function</code> declarations, to the top of the 
nearest surrounding scope.</p>

<pre><code>// var statements got moved here
var bar, someValue; // default to &#39;undefined&#39;

// the function declaration got moved up too
function test(data) {
    var goo, i, e; // missing block scope moves these here
    if (false) {
        goo = 1;

    } else {
        goo = 2;
    }
    for(i = 0; i &lt; 100; i++) {
        e = data[i];
    }
}

bar(); // fails with a TypeError since bar is still &#39;undefined&#39;
someValue = 42; // assignments are not affected by hoisting
bar = function() {};

test();
</code></pre>

<p>Missing block scoping will not only move <code>var</code> statements out of loops and
their bodies, it will also make the results of certain <code>if</code> constructs 
non-intuitive.</p>

<p>In the original code, although the <code>if</code> statement seemed to modify the <em>global 
variable</em> <code>goo</code>, it actually modifies the <em>local variable</em> - after hoisting 
has been applied.</p>

<p>Without knowledge of <em>hoisting</em>, one might suspect the code below would raise a
<code>ReferenceError</code>.</p>

<pre><code>// check whether SomeImportantThing has been initialized
if (!SomeImportantThing) {
    var SomeImportantThing = {};
}
</code></pre>

<p>But of course, this works due to the fact that the <code>var</code> statement is being 
moved to the top of the <em>global scope</em>.</p>

<pre><code>var SomeImportantThing;

// other code might initialize SomeImportantThing here, or not

// make sure it&#39;s there
if (!SomeImportantThing) {
    SomeImportantThing = {};
}
</code></pre>

</div><div><h3>Name Resolution Order</h3>

<p>All scopes in JavaScript, including the <em>global scope</em>, have the special name 
<a href="#function.this"><code>this</code></a>, defined in them, which refers to the <em>current object</em>. </p>

<p>Function scopes also have the name <a href="#function.arguments"><code>arguments</code></a>, defined in
them, which contains the arguments that were passed to the function.</p>

<p>For example, when trying to access a variable named <code>foo</code> inside the scope of a 
function, JavaScript will look up the name in the following order:</p>

<ol>
<li>In case there is a <code>var foo</code> statement in the current scope, use that.</li>
<li>If one of the function parameters is named <code>foo</code>, use that.</li>
<li>If the function itself is called <code>foo</code>, use that.</li>
<li>Go to the next outer scope, and start with <strong>#1</strong> again.</li>
</ol>

<aside>
  <p><strong>Note:</strong> Having a parameter called <code>arguments</code> will <strong>prevent</strong> the creation 
  of the default <code>arguments</code> object.</p>
</aside>

</div><div><h3>Namespaces</h3>

<p>A common problem associated with having only one global namespace is the
likelihood of running into problems where variable names clash. In JavaScript,
this problem can easily be avoided with the help of <em>anonymous wrappers</em>.</p>

<pre><code>(function() {
    // a self contained "namespace"

    window.foo = function() {
        // an exposed closure
    };

})(); // execute the function immediately
</code></pre>

<p>Unnamed functions are considered <a href="#function.general">expressions</a>; so in order to
being callable, they must first be evaluated.</p>

<pre><code>( // evaluate the function inside the parentheses
function() {}
) // and return the function object
() // call the result of the evaluation
</code></pre>

<p>There are other ways to evaluate and directly call the function expression
which, while different in syntax, behave the same way.</p>

<pre><code>// A few other styles for directly invoking the 
!function(){}()
+function(){}()
(function(){}());
// and so on...
</code></pre>

</div><div><h3>結語</h3>

<p>It is recommended to always use an <em>anonymous wrapper</em> to encapsulate code in 
its own namespace. This does not only protect code against name clashes, but it 
also allows for better modularization of programs.</p>

<p>Additionally, the use of global variables is considered <strong>bad practice</strong>. <strong>Any</strong>
use of them indicates badly written code that is prone to errors and hard to maintain.</p></div></article></section><section id="array"><!-- Introduction--><header id="array.intro"><h1>陣列</h1></header><!-- Articles--><article id="array.general"><h2>Array 迴圈和屬性</h2><div><p>雖然在 Javascript 中 Array 都是 Objects，但是沒有好的理由要使用他
在 <a href="#object.forinloop"><code>for in</code></a> 的迴圈中。事實上有很多原因要避免使用 <code>for in</code> 在 Array 之中</p>

<aside>
  <p><strong>注意:</strong> Javascript Arrays <strong>不是</strong> <em>關連性 Arrays</em>
  只有 <a href="#object.general">objects</a> 來管理建值的相對應關係
  Arrays 是<strong>保持</strong> 順序的，Objects <strong>則沒有</strong></p>
</aside>

<p>因為 <code>for in</code> 迴圈會列舉所有在原型 Array 上的屬性因為他會使用<a href="#object.hasownproperty"><code>hasOwnProperty</code></a>, 這會使得 Array 比原本的 <code>for</code> 迴圈慢上二十幾倍</p>

</div><div><h3>迴圈</h3>

<p>為了要達到最好的性能所以最好使用 <code>for</code> 迴圈來讀取一個 Array 裡面的數值。</p>

<pre><code>var list = [1, 2, 3, 4, 5, ...... 100000000];
for(var i = 0, l = list.length; i &lt; l; i++) {
    console.log(list[i]);
}
</code></pre>

<p>在上面的例子中利用 <code>l = list.length</code> 來處理 Array 的長度問題。</p>

<p>雖然 <code>length</code> 屬性是屬於 Array 中其中一個屬性，但是他還使有一定的性能消耗在每次循環的訪問。
近期 Javascript 使用 <strong>may</strong> 來解決在這上面的效率問題，但是在現在的引擎上還不一定有支援。</p>

<p>實際上，不使用暫存 Array 長度的方式比使用暫存的版本還要慢很多。</p>

</div><div><h3><code>length</code> 的屬性</h3>

<p><code>length</code> 屬性中的 <em>getter</em> 直接回傳在 Array 之中的程度，而 <em>setter</em> 可以用來 <strong>刪除</strong> Array。</p>

<pre><code>var foo = [1, 2, 3, 4, 5, 6];
foo.length = 3;
foo; // [1, 2, 3]

foo.length = 6;
foo.push(4);
foo; // [1, 2, 3, undefined, undefined, undefined, 4]
</code></pre>

<p>在上面的例子可以看到，如果給的長度比較小他就會去刪除 Array 中的數值。如果比較大的話，他就會自己增加一些 <code>undefined</code> 的數值進去</p>

</div><div><h3>結語</h3>

<p>為了達到更好的效率，建議使用 <code>for</code> 迴圈還有暫存 <code>length</code> 的屬性。
而 <code>for in</code> 迴圈則是會讓程式中有更多的錯誤和性能問題。</p></div></article><article id="array.constructor"><h2><code>Array</code> 的建構函式</h2><div><p><code>Array</code> 的建構函式在處理參數上一直有模糊的地帶，所以建議使用 <code>array</code>的字面語法來使用 - <code>[]</code> - 來新增一個的Array</p>

<pre><code>[1, 2, 3]; // 結果: [1, 2, 3]
new Array(1, 2, 3); // 結果: [1, 2, 3]

[3]; // 結果: [3]
new Array(3); // 結果: []
new Array(&#39;3&#39;) // 結果: [&#39;3&#39;]
</code></pre>

<p>在上面的範例 <code>new Array(3)</code> 當只有一個參數傳入到 <code>Array</code> 的建構函數
且那個參數事宜個數字，建構函數會回傳空值
但是 <code>Array</code> 長度的屬性會變成跟那個參數一樣（以此範例來看他回傳的長度為 3）
<strong>注意</strong> 只有他長度的屬性會被設定，整個 Array裡面的數值都不會初始化</p>

<pre><code>var arr = new Array(3);
arr[1]; // undefined
1 in arr; // false, 數值沒有被設定進去
</code></pre>

<p>被設定用來當做 <code>Array</code> 的長度只有少數情況使用
先設定 <code>Array</code> 的長度可以用一下的範例來避免使用 <code>for loop</code> 的麻煩</p>

<pre><code>new Array(count + 1).join(stringToRepeat);
</code></pre>

</div><div><h3>結語</h3>

<p><code>Array</code> 的建構函式需要避免，建議使用字面語法。因為他們比較簡短、也更增加閱讀性</p></div></article></section><section id="types"><!-- Introduction--><header id="types.intro"><h1>類型</h1></header><!-- Articles--><article id="types.equality"><h2>Equality and Comparisons</h2><div><p>JavaScript has two different ways of comparing the values of objects for equality. </p>

</div><div><h3>The Equality Operator</h3>

<p>The equality operator consists of two equal signs: <code>==</code></p>

<p>JavaScript features <em>weak typing</em>. This means that the equality operator 
<strong>coerces</strong> types in order to compare them.</p>

<pre><code>""           ==   "0"           // false
0            ==   ""            // true
0            ==   "0"           // true
false        ==   "false"       // false
false        ==   "0"           // true
false        ==   undefined     // false
false        ==   null          // false
null         ==   undefined     // true
" \t\r\n"    ==   0             // true
</code></pre>

<p>The above table shows the results of the type coercion, and it is the main reason 
why the use of <code>==</code> is widely regarded as bad practice. It introduces
hard-to-track-down bugs due to its complicated conversion rules.</p>

<p>Additionally, there is also a performance impact when type coercion is in play;
for example, a string has to be converted to a number before it can be compared
to another number.</p>

</div><div><h3>The Strict Equality Operator</h3>

<p>The strict equality operator consists of <strong>three</strong> equal signs: <code>===</code>.</p>

<p>It works like the normal equality operator, except that strict equality 
operator does <strong>not</strong> perform type coercion between its operands.</p>

<pre><code>""           ===   "0"           // false
0            ===   ""            // false
0            ===   "0"           // false
false        ===   "false"       // false
false        ===   "0"           // false
false        ===   undefined     // false
false        ===   null          // false
null         ===   undefined     // false
" \t\r\n"    ===   0             // false
</code></pre>

<p>The above results are a lot clearer and allow for early breakage of code. This
hardens code to a certain degree and also gives performance improvements in case
the operands are of different types.</p>

</div><div><h3>Comparing Objects</h3>

<p>While both <code>==</code> and <code>===</code> are called <strong>equality</strong> operators, they behave 
differently when at least one of their operands is an <code>Object</code>.</p>

<pre><code>{} === {};                   // false
new String(&#39;foo&#39;) === &#39;foo&#39;; // false
new Number(10) === 10;       // false
var foo = {};
foo === foo;                 // true
</code></pre>

<p>Here, both operators compare for <strong>identity</strong> and <strong>not</strong> equality; that is, they
will compare for the same <strong>instance</strong> of the object, much like <code>is</code> in Python 
and pointer comparison in C.</p>

</div><div><h3>In Conclusion</h3>

<p>It is highly recommended to only use the <strong>strict equality</strong> operator. In cases
where types need to be coerced, it should be done <a href="#types.casting">explicitly</a> 
and not left to the language&#39;s complicated coercion rules.</p></div></article><article id="types.typeof"><h2>The <code>typeof</code> Operator</h2><div><p>The <code>typeof</code> operator (together with 
<a href="#types.instanceof"><code>instanceof</code></a>) is probably the biggest 
design flaw of JavaScript, as it is almost <strong>completely broken</strong>.</p>

<p>Although <code>instanceof</code> still has limited uses, <code>typeof</code> really has only one
practical use case, which does <strong>not</strong> happen to be checking the type of an 
object. </p>

<aside>
  <p><strong>Note:</strong> While <code>typeof</code> can also be called with a function like syntax, i.e.
  <code>typeof(obj)</code>, this is not a function call. The parentheses behave as normal
  and the return value will be used as the operand of the <code>typeof</code> operator.
  There is <strong>no</strong> <code>typeof</code> function.</p>
</aside>

</div><div><h3>The JavaScript Type Table</h3>

<pre><code>Value               Class      Type
-------------------------------------
"foo"               String     string
new String("foo")   String     object
1.2                 Number     number
new Number(1.2)     Number     object
true                Boolean    boolean
new Boolean(true)   Boolean    object
new Date()          Date       object
new Error()         Error      object
[1,2,3]             Array      object
new Array(1, 2, 3)  Array      object
new Function("")    Function   function
/abc/g              RegExp     object (function in Nitro/V8)
new RegExp("meow")  RegExp     object (function in Nitro/V8)
{}                  Object     object
new Object()        Object     object
</code></pre>

<p>In the above table, <em>Type</em> refers to the value that the <code>typeof</code> operator returns.
As can be clearly seen, this value is anything but consistent.</p>

<p>The <em>Class</em> refers to the value of the internal <code>[[Class]]</code> property of an object.</p>

<aside>
  <p><strong>From the Specification:</strong> The value of <code>[[Class]]</code> can be one of the
  following strings. <code>Arguments</code>, <code>Array</code>, <code>Boolean</code>, <code>Date</code>, <code>Error</code>, 
  <code>Function</code>, <code>JSON</code>, <code>Math</code>, <code>Number</code>, <code>Object</code>, <code>RegExp</code>, <code>String</code>.</p>
</aside>

<p>In order to retrieve the value of <code>[[Class]]</code>, one has to make use of the
<code>toString</code> method of <code>Object.prototype</code>.</p>

</div><div><h3>The Class of an Object</h3>

<p>The specification gives exactly one way of accessing the <code>[[Class]]</code> value,
with the use of <code>Object.prototype.toString</code>. </p>

<pre><code>function is(type, obj) {
    var clas = Object.prototype.toString.call(obj).slice(8, -1);
    return obj !== undefined &amp;&amp; obj !== null &amp;&amp; clas === type;
}

is(&#39;String&#39;, &#39;test&#39;); // true
is(&#39;String&#39;, new String(&#39;test&#39;)); // true
</code></pre>

<p>In the above example, <code>Object.prototype.toString</code> gets called with the value of
<a href="#function.this">this</a> being set to the object whose <code>[[Class]]</code> value should be 
retrieved.</p>

<aside class="es5"><p><strong>ES5 Note:</strong> For convenience the return value of <code>Object.prototype.toString</code> 
  for both <code>null</code> and <code>undefined</code> was <strong>changed</strong> from <code>Object</code> to <code>Null</code> and 
  <code>Undefined</code> in ECMAScript 5.</p>
</aside>

</div><div><h3>Testing for Undefined Variables</h3>

<pre><code>typeof foo !== &#39;undefined&#39;
</code></pre>

<p>The above will check whether <code>foo</code> was actually declared or not; just 
referencing it would result in a <code>ReferenceError</code>. This is the only thing
<code>typeof</code> is actually useful for.</p>

</div><div><h3>In Conclusion</h3>

<p>In order to check the type of an object, it is highly recommended to use 
<code>Object.prototype.toString</code> because this is the only reliable way of doing so. 
As shown in the above type table, some return values of <code>typeof</code> are not defined 
in the specification; thus, they can differ between implementations.</p>

<p>Unless checking whether a variable is defined, <code>typeof</code> should be avoided.</p></div></article><article id="types.instanceof"><h2>The <code>instanceof</code> Operator</h2><div><p>The <code>instanceof</code> operator compares the constructors of its two operands. It is 
only useful when comparing custom made objects. Used on built-in types, it is
nearly as useless as the <a href="#types.typeof">typeof operator</a>.</p>

</div><div><h3>Comparing Custom Objects</h3>

<pre><code>function Foo() {}
function Bar() {}
Bar.prototype = new Foo();

new Bar() instanceof Bar; // true
new Bar() instanceof Foo; // true

// This just sets Bar.prototype to the function object Foo,
// but not to an actual instance of Foo
Bar.prototype = Foo;
new Bar() instanceof Foo; // false
</code></pre>

</div><div><h3>Using <code>instanceof</code> with Native Types</h3>

<pre><code>new String(&#39;foo&#39;) instanceof String; // true
new String(&#39;foo&#39;) instanceof Object; // true

&#39;foo&#39; instanceof String; // false
&#39;foo&#39; instanceof Object; // false
</code></pre>

<p>One important thing to note here is that <code>instanceof</code> does not work on objects 
that originate from different JavaScript contexts (e.g. different documents
in a web browser), since their constructors will not be the exact same object.</p>

</div><div><h3>In Conclusion</h3>

<p>The <code>instanceof</code> operator should <strong>only</strong> be used when dealing with custom made 
objects that originate from the same JavaScript context. Just like the
<a href="#types.typeof"><code>typeof</code></a> operator, every other use of it should be <strong>avoided</strong>.</p></div></article><article id="types.casting"><h2>Type Casting</h2><div><p>JavaScript is a <em>weakly typed</em> language, so it will apply <em>type coercion</em>
<strong>wherever</strong> possible.</p>

<pre><code>// These are true
new Number(10) == 10; // Number.toString() is converted
                      // back to a number

10 == &#39;10&#39;;           // Strings gets converted to Number
10 == &#39;+10 &#39;;         // More string madness
10 == &#39;010&#39;;          // And more 
isNaN(null) == false; // null converts to 0
                      // which of course is not NaN

// These are false
10 == 010;
10 == &#39;-10&#39;;
</code></pre>

<aside class="es5"><p><strong>ES5 Note:</strong> Number literals that start with a <code>0</code> are interpreted as octal 
  (Base 8). Octal support for these has been <strong>removed</strong> in ECMAScript 5 strict 
  mode.</p>
</aside>

<p>To avoid the issues above, use of the <a href="#types.equality">strict equal operator</a> 
is <strong>highly</strong> recommended. Although this avoids a lot of common pitfalls, there 
are still many further issues that arise from JavaScript&#39;s weak typing system.</p>

</div><div><h3>Constructors of Built-In Types</h3>

<p>The constructors of the built in types like <code>Number</code> and <code>String</code> behave
differently when being used with the <code>new</code> keyword and without it.</p>

<pre><code>new Number(10) === 10;     // False, Object and Number
Number(10) === 10;         // True, Number and Number
new Number(10) + 0 === 10; // True, due to implicit conversion
</code></pre>

<p>Using a built-in type like <code>Number</code> as a constructor will create a new <code>Number</code> 
object, but leaving out the <code>new</code> keyword will make the <code>Number</code> function behave
like a converter.</p>

<p>In addition, passing literals or non-object values will result in even more
type coercion.</p>

<p>The best option is to cast to one of the three possible types <strong>explicitly</strong>.</p>

</div><div><h3>Casting to a String</h3>

<pre><code>&#39;&#39; + 10 === &#39;10&#39;; // true
</code></pre>

<p>By prepending an empty string, a value can easily be cast to a string.</p>

</div><div><h3>Casting to a Number</h3>

<pre><code>+&#39;10&#39; === 10; // true
</code></pre>

<p>Using the <strong>unary</strong> plus operator, it is possible to cast to a number.</p>

</div><div><h3>Casting to a Boolean</h3>

<p>By using the <strong>not</strong> operator twice, a value can be converted a boolean.</p>

<pre><code>!!&#39;foo&#39;;   // true
!!&#39;&#39;;      // false
!!&#39;0&#39;;     // true
!!&#39;1&#39;;     // true
!!&#39;-1&#39;     // true
!!{};      // true
!!true;    // true
</code></pre></div></article></section><section id="core"><!-- Introduction--><header id="core.intro"><h1>核心</h1></header><!-- Articles--><article id="core.eval"><h2>為什麼不要使用 <code>eval</code></h2><div><p>因為 <code>eval</code> 函數會在 Javascript 的區域性的區間執行那段程式碼。</p>

<pre><code>var foo = 1;
function test() {
    var foo = 2;
    eval(&#39;foo = 3&#39;);
    return foo;
}
test(); // 3
foo; // 1
</code></pre>

<p>但是， <code>eval</code> 只接受直接的呼叫而且那個函數只能叫做 <code>eval</code>，才能在一個區段中執行。</p>

<pre><code>var foo = 1;
function test() {
    var foo = 2;
    var bar = eval;
    bar(&#39;foo = 3&#39;);
    return foo;
}
test(); // 2
foo; // 3
</code></pre>

<p>所有的 <code>eval</code> 都應該去比免試用。有 99.9% 的使用情況都可以 <strong>不必</strong> 使用到而達到同等效果。</p>

</div><div><h3>偽裝的 <code>eval</code></h3>

<p><a href="#other.timeouts">定時函數</a> <code>setTimeout</code> 和 <code>setInterval</code> 都可以接受一個字串當做他們第一個參數。這些字串 <strong>永遠</strong> 都會在全域範圍內執行，因此在這種情況下 <code>eval</code> 沒有被直接的使用。</p>

</div><div><h3>安全上的顧慮</h3>

<p><code>eval</code> 同樣有安全上的問題，因為所有的程式碼都可以被直接執行。
而他不應去執行一串未知的字串或是來自不幸任的來源。</p>

</div><div><h3>結語</h3>

<p><code>eval</code> 應該永遠不要去只用它，任何的程式在被他執行後都有性能和安全上的考慮。如果有情況需要去使用他，他都不應該列為第一順位的解決方法。</p>

<p>應該有更好的方法能夠去使用，但是最好都不要去使用 <code>eval</code>。</p></div></article><article id="core.undefined"><h2><code>undefined</code> 和 <code>null</code></h2><div><p>JavaScript 中有兩個表示空值的方式， <code>null</code> 和 <code>undefined</code> ， <code>undefined</code>式比較常用的一種。</p>

</div><div><h3><code>undefined</code> 的值</h3>

<p><code>undefined</code> 是一個值為 <code>undefined</code> 的類型。</p>

<p>語言中也定義了一個全域變數，它的值為 <code>undefined</code>，這個變數的被稱作 <code>undefined</code> 。
這個變數 <strong>不是</strong> 一個常數，也不是一個關鍵字。這表示它的值可以被輕易的覆蓋。</p>

<aside class="es5"><p><strong>ES5 提示: <em>* <code>undefined</code> 在 ECMAScript 5 裡 *</em>不再是</strong> <em>可寫</em> 的
  但是它的名稱還是可以被隱藏，比如說定義一個函數為 <code>undefined</code>。</p>
</aside>

<p>這裡有一些例子會回傳 <code>undefined</code> 的值：</p>

<ul>
<li>進入尚未修改的全域變數 <code>undefined</code>。</li>
<li>進入一個宣告但 <strong>尚未</strong> 初始化的變數。</li>
<li><code>return</code> 表示式中沒有返回任何內容。</li>
<li>呼叫不存在的屬性。</li>
<li>函式參數沒有被傳遞數值。</li>
<li>任何被被設定為 <code>undefined</code> 的變數。</li>
<li>任何表達式中形式為 <code>void(expression)</code></li>
</ul>

</div><div><h3>處理 <code>undefined</code> 值的改變</h3>

<p>由於全域變數 <code>undefined</code> 只有保存 <code>undefined</code> 類型實際值的一個副本，指定了一個新的值並 <strong>不會</strong> 改變 <code>undefined</code>類型裡面的值。</p>

<p>為了避免去改變 <code>undefined</code> 的值，常用的技巧就是加上一個新的變數到 <a href="#function.scopes">匿名包裝器</a>。在使用的時候，這個參數不會接受任何的值。</p>

<pre><code>var undefined = 123;
(function(something, foo, undefined) {
    // undefined 在區域區間內得到了 `undefined` 的值

})(&#39;Hello World&#39;, 42);
</code></pre>

<p>另外一個可以得到同樣的效果就是在內部宣告一個變數</p>

<pre><code>var undefined = 123;
(function(something, foo) {
    var undefined;
    ...

})(&#39;Hello World&#39;, 42);
</code></pre>

<p>唯一的不同就是在下者會多 4 個多 bytes 用來壓縮檔案，而且函數內野沒有其他需要使用 <code>var</code></p>

</div><div><h3>使用 <code>null</code></h3>

<p>JavaScript 中所使用的 <code>undefined</code> 類似別的語言中的 <em>null</em> , 但實際上在 JavaScript 中的 <code>null</code> 算是另外一個類型。</p>

<p>它在 JavaScript 有些可以使用的地方 （例如說宣告一個原型的終結，例如 <code>Foo.prototype = null</code> ）。
但是在大部分的時候可以用 <code>undefined</code>，來取代。</p></div></article><article id="core.semicolon"><h2>自動插入分號</h2><div><p>雖然 JavaScript 有 C 語言的語法，但是他不強制一定要加上分號。
所以分號可以被忽略。</p>

<p>Javascript 並 <strong>不是</strong> 一個不需要分號的語言。實際上，它需要分號來讓程式碼更容易被理解。因此 Javascript 的編譯器中遇到了缺少分號的情形，它會自動的在程式碼中插入分號。</p>

<pre><code>var foo = function() {
} // 編輯錯誤，因沒分號
test()
</code></pre>

<p>這時候編譯器在編輯的時候，會自動的加上分號，然後重新編輯。</p>

<pre><code>var foo = function() {
}; // 沒有錯誤，編輯繼續
test()
</code></pre>

<p>自動的加入分號是被認為 <strong>最大</strong> 的設計缺陷之一，因為它能改變程式碼的行為。</p>

</div><div><h3>工作原理</h3>

<p>下面的程式碼中沒有使用任何的分號，所以編譯器需要去決定在哪些地方加入分號。</p>

<pre><code>(function(window, undefined) {
    function test(options) {
        log(&#39;testing!&#39;)

        (options.list || []).forEach(function(i) {

        })

        options.value.test(
            &#39;long string to pass here&#39;,
            &#39;and another long string to pass&#39;
        )

        return
        {
            foo: function() {}
        }
    }
    window.test = test

})(window)

(function(window) {
    window.someLibrary = {}

})(window)
</code></pre>

<p>下面的程式碼是編譯器 <strong>猜測</strong> 的結果。</p>

<pre><code>(function(window, undefined) {
    function test(options) {

        // 沒有加入分號，兩行被合併為一行
        log(&#39;testing!&#39;)(options.list || []).forEach(function(i) {

        }); // &lt;- 插入分號

        options.value.test(
            &#39;long string to pass here&#39;,
            &#39;and another long string to pass&#39;
        ); // &lt;- 插入分號

        return; // &lt;- 插入分號，改變了 return 的表達行為
        { // 作為另一個程式碼的處理

            // 被當做一個獨立的函數來看
            foo: function() {} 
        }; // &lt;- 插入分號
    }
    window.test = test; // &lt;- 插入分號

// 兩行又被合併
})(window)(function(window) {
    window.someLibrary = {}; // &lt;- 插入分號

})(window); //&lt;- 插入分號
</code></pre>

<aside>
  <p><strong>注意:</strong> 在這個範例中 Javascript 編譯器沒有正確的處理 <code>return</code> ，因為緊接的換行符號。
  雖然這不能算是自動分號插入的錯誤，但是它是非常不樂見的效果。</p>
</aside>

<p>編譯器在上面的程式碼中改變了原本程式碼的行為。在一些情況下，會做出 <strong>錯誤的行為</strong></p>

</div><div><h3>前置括號</h3>

<p>在這種前置括號的情況下，編譯器 <strong>不會</strong> 自動的插入分號。</p>

<pre><code>log(&#39;testing!&#39;)
(options.list || []).forEach(function(i) {})
</code></pre>

<p>上面的程式碼被編譯器轉為只有一行程式</p>

<pre><code>log(&#39;testing!&#39;)(options.list || []).forEach(function(i) {})
</code></pre>

<p>以上的範例中 <code>log</code> 有 <strong>很大</strong> 的可能 <strong>不是</strong> 回傳一個函數。然而這個情況下會出現 <code>TypeError</code> 的錯誤或是會出現 <code>undefined is not a function</code> .</p>

</div><div><h3>結語</h3>

<p>建議永遠 <strong>不要</strong> 忽略分號。同樣的也建議大括號應在他對應的表達式在同一行。在 <code>if... else...</code>的表達式中也是如此，不應省略大括號。
這個習慣可以不僅僅是讓你的程式更一致，也可以避免編譯器因為改變程式而出錯。</p></div></article><article id="core.delete"><h2>The <code>delete</code> Operator</h2><div><p>In short, it&#39;s <em>impossible</em> to delete global variables, functions and some other
stuff in JavaScript which have a <code>DontDelete</code> attribute set.</p>

</div><div><h3>Global code and Function code</h3>

<p>When a variable or a function is defined in a global or a <a href="#function.scopes">function
scope</a> it is a property of either the Activation object or
the Global object. Such properties have a set of attributes, one of which is
<code>DontDelete</code>. Variable and function declarations in global and function code
always create properties with <code>DontDelete</code>, and therefore cannot be deleted.</p>

<pre><code>// global variable:
var a = 1; // DontDelete is set
delete a; // false
a; // 1

// normal function:
function f() {} // DontDelete is set
delete f; // false
typeof f; // "function"

// reassigning doesn&#39;t help:
f = 1;
delete f; // false
f; // 1
</code></pre>

</div><div><h3>Explicit properties</h3>

<p>Explicitly set properties can be deleted normally.</p>

<pre><code>// explicitly set property:
var obj = {x: 1};
obj.y = 2;
delete obj.x; // true
delete obj.y; // true
obj.x; // undefined
obj.y; // undefined
</code></pre>

<p>In the example above, <code>obj.x</code> and <code>obj.y</code> can be deleted because they have no 
<code>DontDelete</code> atribute. That&#39;s why the example below works too.</p>

<pre><code>// this works fine, except for IE:
var GLOBAL_OBJECT = this;
GLOBAL_OBJECT.a = 1;
a === GLOBAL_OBJECT.a; // true - just a global var
delete GLOBAL_OBJECT.a; // true
GLOBAL_OBJECT.a; // undefined
</code></pre>

<p>Here we use a trick to delete <code>a</code>. <a href="#function.this"><code>this</code></a> here refers 
to the Global object and we explicitly declare variable <code>a</code> as its property 
which allows us to delete it.</p>

<p>IE (at least 6-8) has some bugs, so the code above doesn&#39;t work.</p>

</div><div><h3>Function arguments and built-ins</h3>

<p>Functions&#39; normal arguments, <a href="#function.arguments"><code>arguments</code> objects</a> 
and built-in properties also have <code>DontDelete</code> set.</p>

<pre><code>// function arguments and properties:
(function (x) {

  delete arguments; // false
  typeof arguments; // "object"

  delete x; // false
  x; // 1

  function f(){}
  delete f.length; // false
  typeof f.length; // "number"

})(1);
</code></pre>

</div><div><h3>Host objects</h3>

<p>The behaviour of <code>delete</code> operator can be unpredictable for hosted objects. Due
to the specification, host objects are allowed to implement any kind of behavior. </p>

</div><div><h3>In conclusion</h3>

<p>The <code>delete</code> operator often has unexpected behaviour and can only be safely
used to delete explicitly set properties on normal objects.</p></div></article></section><section id="other"><!-- Introduction--><header id="other.intro"><h1>其他</h1></header><!-- Articles--><article id="other.timeouts"><h2><code>setTimeout</code> and <code>setInterval</code></h2><div><p>Since JavaScript is asynchronous, it is possible to schedule the execution of a 
function using the <code>setTimeout</code> and <code>setInterval</code> functions.</p>

<aside>
  <p><strong>Note:</strong> Timeouts are <strong>not</strong> part of the ECMAScript Standard. They are
  implemented as part of the <a href="http://en.wikipedia.org/wiki/Document_Object_Model" title="Document Object Model">DOM</a>.</p>
</aside>

<pre><code>function foo() {}
var id = setTimeout(foo, 1000); // returns a Number &gt; 0
</code></pre>

<p>When <code>setTimeout</code> is called, it returns the ID of the timeout and schedule
<code>foo</code> to run <strong>approximately</strong> one thousand milliseconds in the future. 
<code>foo</code> will then be executed <strong>once</strong>.</p>

<p>Depending on the timer resolution of the JavaScript engine running the code, as
well as the fact that JavaScript is single threaded and other code that gets
executed might block the thread, it is by <strong>no means</strong> a safe bet that one will
get the exact delay specified in the <code>setTimeout</code> call.</p>

<p>The function that was passed as the first parameter will get called by the
<em>global object</em>, which means that <a href="#function.this"><code>this</code></a> inside the called function 
refers to the global object.</p>

<pre><code>function Foo() {
    this.value = 42;
    this.method = function() {
        // this refers to the global object
        console.log(this.value); // will log undefined
    };
    setTimeout(this.method, 500);
}
new Foo();
</code></pre>

<aside>
  <p><strong>Note:</strong> As <code>setTimeout</code> takes a <strong>function object</strong> as its first parameter, an
  common mistake is to use <code>setTimeout(foo(), 1000)</code>, which will use the 
  <strong>return value</strong> of the call <code>foo</code> and <strong>not</strong> <code>foo</code>. This is, most of the time, 
  a silent error, since when the function returns <code>undefined</code> <code>setTimeout</code> will 
  <strong>not</strong> raise any error.</p>
</aside>

</div><div><h3>Stacking Calls with <code>setInterval</code></h3>

<p>While <code>setTimeout</code> only runs the function once, <code>setInterval</code> - as the name 
suggests - will execute the function <strong>every</strong> <code>X</code> milliseconds, but its use is 
discouraged. </p>

<p>When code that is being executed blocks the timeout call, <code>setInterval</code> will 
still issue more calls to the specified function. This can, especially with small
intervals, result in function calls stacking up.</p>

<pre><code>function foo(){
    // something that blocks for 1 second
}
setInterval(foo, 1000);
</code></pre>

<p>In the above code, <code>foo</code> will get called once and will then block for one second.</p>

<p>While <code>foo</code> blocks the code, <code>setInterval</code> will still schedule further calls to
it. Now, when <code>foo</code> has finished, there will already be <strong>ten</strong> further calls to
it waiting for execution.</p>

</div><div><h3>Dealing with Possible Blocking Code</h3>

<p>The easiest solution, as well as most controllable solution, is to use <code>setTimeout</code> within
the function itself.</p>

<pre><code>function foo(){
    // something that blocks for 1 second
    setTimeout(foo, 1000);
}
foo();
</code></pre>

<p>Not only does this encapsulate the <code>setTimeout</code> call, but it also prevents the
stacking of calls and gives additional control. <code>foo</code> itself can now decide 
whether it wants to run again or not.</p>

</div><div><h3>Manually Clearing Timeouts</h3>

<p>Clearing timeouts and intervals works by passing the respective ID to
<code>clearTimeout</code> or <code>clearInterval</code>, depending on which <code>set</code> function was used
in the first place.</p>

<pre><code>var id = setTimeout(foo, 1000);
clearTimeout(id);
</code></pre>

</div><div><h3>Clearing All Timeouts</h3>

<p>As there is no built-in method for clearing all timeouts and/or intervals, 
it is necessary to use brute force in order to achieve this functionality.</p>

<pre><code>// clear "all" timeouts
for(var i = 1; i &lt; 1000; i++) {
    clearTimeout(i);
}
</code></pre>

<p>But there might still be timeouts that are unaffected by this arbitrary number.
Another way of doing this is to consider that the ID given to a timeout is
incremented by one every time you call <code>setTimeout</code>.</p>

<pre><code>// clear "all" timeouts
var biggestTimeoutId = window.setTimeout(function(){}, 1),
i;
for(i = 1; i &lt;= biggestTimeoutId; i++) {
    clearTimeout(i);
}
</code></pre>

<p>Even though this works on all major browsers today, it isn&#39;t specified that
the IDs should be ordered that way and it may change. Therefore, it is instead
recommended to keep track of all the timeout IDs, so they can be cleared
specifically.</p>

</div><div><h3>Hidden Use of <code>eval</code></h3>

<p><code>setTimeout</code> and <code>setInterval</code> can also take a string as their first parameter.
This feature should <strong>never</strong> be used because it internally makes use of <code>eval</code>.</p>

<aside>
  <p><strong>Note:</strong> Since the timeout functions are <strong>not</strong> specified by the ECMAScript
  standard, the exact workings when a string is passed to them might differ in
  various JavaScript implementations. For example, Microsoft&#39;s JScript uses
  the <code>Function</code> constructor in place of <code>eval</code>.</p>
</aside>

<pre><code>function foo() {
    // will get called
}

function bar() {
    function foo() {
        // never gets called
    }
    setTimeout(&#39;foo()&#39;, 1000);
}
bar();
</code></pre>

<p>Since <code>eval</code> is not getting called <a href="#core.eval">directly</a> in this case, the string 
passed to <code>setTimeout</code> will be executed in the <em>global scope</em>; thus, it will 
not use the local variable <code>foo</code> from the scope of <code>bar</code>.</p>

<p>It is further recommended to <strong>not</strong> use a string to pass arguments to the
function that will get called by either of the timeout functions. </p>

<pre><code>function foo(a, b, c) {}

// NEVER use this
setTimeout(&#39;foo(1, 2, 3)&#39;, 1000)

// Instead use an anonymous function
setTimeout(function() {
    foo(a, b, c);
}, 1000)
</code></pre>

<aside>
  <p><strong>Note:</strong> While it is also possible to use the syntax 
  <code>setTimeout(foo, 1000, a, b, c)</code>, it is not recommended, as its use may lead
  to subtle errors when used with <a href="#function.this">methods</a>. </p>
</aside>

</div><div><h3>In Conclusion</h3>

<p>A string should <strong>never</strong> be used as the parameter of <code>setTimeout</code> or 
<code>setInterval</code>. It is a clear sign of <strong>really</strong> bad code, when arguments need 
to be supplied to the function that gets called. An <em>anonymous function</em> should
be passed that then takes care of the actual call.</p>

<p>Furthermore, the use of <code>setInterval</code> should be avoided because its scheduler is not
blocked by executing JavaScript.</p></div></article></section><!-- Footer--><footer><p>Copyright &copy; 2011. Built with 
<a href="http://nodejs.org/">Node.js </a>using a
<a href="https://github.com/visionmedia/jade/">jade </a>template. 
Hosted by 
<a href="http://cramerdev.com">Cramer Development</a>.
</p></footer><script src="http://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script><script src="../javascript/prettify.js"></script><script src="../javascript/plugin.js"></script><script src="../javascript/garden.js"></script></body></html>